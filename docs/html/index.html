<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INF224 - Travaux Pratiques C++/Objet et Java/Swing: Projet de développement logiciel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">INF224 - Travaux Pratiques C++/Objet et Java/Swing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Projet de développement logiciel </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__mnt_c_Users_Usuario_Desktop_P2_INF224_TP_scratch_DA_SILVA_BUENO_Tarcisio_README"></a> <b>Nom du projet :</b> INF224 - Travaux Pratiques C++/Objet et Java/Swing</p>
<p><b>Auteur :</b> Tarcisio DA SILVA BUENO</p>
<p><b>Objectif du projet :</b> Créer l'ébauche du logiciel d'une set-top box multimédia permettant de jouer des vidéos, des films, d'afficher des photos, etc.</p>
<p><b>À propos de ce fichier README :</b> Ce fichier README contient des instructions et des informations importantes concernant ce projet. Il comprend des questions et des réponses sur les différentes étapes du projet.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Travaux Pratiques C++/Objet</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
4e Etape: Photos et videos</h2>
<p><b>Comment appelle-t'on ce type de méthode et comment faut-il les déclarer ?</b></p>
<p>Le type de méthode que vous décrivez est appelé une "méthode purement virtuelle" en C++.</p>
<p>Pour déclarer une méthode comme purement virtuelle, vous utilisez le mot-clé virtual suivi de = 0 à la fin de la déclaration de la méthode. Par exemple :</p>
<div class="fragment"><div class="line">virtual void maMethode() const = 0;</div>
</div><!-- fragment --><p><b>Si vous avez fait ce qui précède comme demandé, il ne sera plus possible d'instancer des objets de la classe de base. Pourquoi ?</b></p>
<p>Lorsqu'une classe contient au moins une méthode purement virtuelle, cette classe est considérée comme une classe abstraite. Les classes abstraites ne peuvent pas être instanciées directement, elles sont destinées à être héritées par d'autres classes.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
5e Etape: Traitement uniforme (en utilisant le polymorphisme)</h2>
<p><b>Quelle est la propriété caractéristique de l'orienté objet qui permet de faire cela ?</b></p>
<p>La propriété caractéristique de l'orienté objet qui permet de traiter de manière uniforme une liste comprenant à la fois des photos et des vidéos sans avoir à se préoccuper de leur type est le polymorphisme. Le polymorphisme permet à une classe dérivée d'hériter des méthodes et des attributs d'une classe de base, et de les redéfinir si nécessaire.</p>
<p><b>Qu'est-il spécifiquement nécessaire de faire dans le cas du C++ ?</b></p>
<p>En C++, pour utiliser le polymorphisme, il est nécessaire de déclarer les méthodes que vous souhaitez redéfinir dans les classes dérivées comme virtual dans la classe de base. Si vous voulez que la méthode soit purement virtuelle (c'est-à-dire qu'elle doit être redéfinie dans toutes les classes dérivées), vous pouvez utiliser virtual suivi de = 0.</p>
<p><b>Quel est le type des éléments du tableau : le tableau doit-il contenir des objets ou des pointeurs vers ces objets ? Pourquoi ? Comparer à Java.</b></p>
<p>le tableau doit contenir des pointeurs vers des objets de ses classes dérivées. Cela permet de traiter de manière uniforme les objets de différentes classes dérivées.</p>
<p>En Java, tous les objets sont manipulés par référence, ce qui signifie que lorsque vous créez un objet et l'assignez à une variable ou le placez dans un tableau, vous travaillez avec une référence à l'objet, pas l'objet lui-même.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
6e étape. Films et tableaux</h2>
<h2><a class="anchor" id="autotoc_md5"></a>
7e étape. Destruction et copie des objets</h2>
<p>Ci-dessous est le résultat de la commande valgrind &ndash;leak-check=full ./myprog.</p>
<div class="fragment"><div class="line">==682== HEAP SUMMARY:</div>
<div class="line">==682==     in use at exit: 0 bytes in 0 blocks</div>
<div class="line">==682==   total heap usage: 26 allocs, 26 frees, 75,351 bytes allocated</div>
<div class="line">==682==</div>
<div class="line">==682== All heap blocks were freed -- no leaks are possible</div>
</div><!-- fragment --><p><b>Parmi les classes précédemment écrites quelles sont celles qu'il faut modifier afin qu'il n'y ait pas de fuite mémoire quand on détruit les objets ? Modifiez le code de manière à l'éviter.</b></p>
<p>Parmi les classes précédemment écrites, la seule qui a le potentiel de causer des fuites de mémoire est la classe <a class="el" href="classFilm.html" title="Classe représentant un film héritant de la classe Video.">Film</a>, car il y a pas mal de "new" qui est utilisé. En tout cas, comme on peut voir le résultat du Valgrind, il n'y a pas de fuites de mémoire, ce qui veut dire que la mémoire a été bien utilisée. Pour obtenir ce résultat, il fallait écrire le destructeur comme montré ci-dessous :</p>
<div class="fragment"><div class="line">~Film()</div>
<div class="line">{</div>
<div class="line">    delete[] chapitres;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>La copie d'objet peut également poser problème quand ils ont des variables d'instance qui sont des pointeurs. Quel est le problème et quelles sont les solutions ? Implementez-en une.</b></p>
<p>Le problème se produit lorsque vous effectuez une copie superficielle d'un objet qui a des pointeurs comme variables d'instance. Dans une copie superficielle, les pointeurs sont copiés, pas les objets auxquels ils pointent. Cela signifie que la copie et l'original pointent vers le même objet. Si l'original est détruit et que sa mémoire est libérée, la copie se retrouve avec un pointeur vers de la mémoire qui a été libérée, ce qui peut entraîner des erreurs.</p>
<p>La solution à ce problème est de faire une copie profonde. Dans une copie profonde, une nouvelle mémoire est allouée pour la copie, et l'objet vers lequel pointe l'original est copié dans la nouvelle mémoire. Cela signifie que la copie et l'original sont complètement indépendants.</p>
<p>Pour implémenter une copie profonde, il faut écrire un construteur de copie:</p>
<div class="fragment"><div class="line">Film(const Film &amp;original) : Video(original), taille(original.taille) {</div>
<div class="line">    chapitres = new int[taille];</div>
<div class="line">    for(int i = 0; i &lt; taille; i++){</div>
<div class="line">        chapitres[i] = original.chapitres[i];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md6"></a>
8e étape. Créer des groupes</h2>
<p><b>On rappelle aussi que la liste d'objets doit en fait être une liste de pointeurs d'objets. Pourquoi ? Comparer à Java.</b></p>
<p>La première raison pour laquelle la liste d'objets doit être une liste de pointeurs est de permettre le polymorphisme.</p>
<p>La deuxième raison est la suivante :</p>
<p>En C++, lorsque vous créez une liste d'objets (comme std::list&lt;Base&gt;), les objets sont stockés directement dans la liste. Si vous retirez un objet de la liste ou si la liste est détruite, l'objet est également détruit. C'est différent de Java, où tous les objets non primitifs sont en fait des références (similaires aux pointeurs en C++). Donc, lorsque vous avez une liste d'objets en Java, vous avez en fait une liste de références. Lorsque la liste est détruite, les références sont détruites, mais pas les objets auxquels elles font référence.</p>
<p>Lorsque l'on utilise une liste de pointeurs, la liste contient des pointeurs vers les objets, et non les objets eux-mêmes. Lorsqu'un pointeur est retiré de la liste ou que la liste est détruite, seul le pointeur est détruit, pas l'objet auquel il pointe.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
10e étape. Gestion cohérente des données</h2>
<p>Pour garantir que seules certaines classes peuvent créer des instances d'une autre classe, il faut rendre les constructeurs protected, puis déclarer la classes <a class="el" href="classDataBase.html" title="Classe pour gérer une base de données multimédia.">DataBase</a> comme friend.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
11e étape. Client / serveur</h2>
<p><b>SEARCH command:</b> The client sends a command in the format SEARCH type name, where type can be either multimedia or group, and name is the name of the multimedia or group to be searched. The server then searches for the multimedia or group with the given name and sends back its attributes. For example, SEARCH multimedia song1 or SEARCH group group1.</p>
<p>**PLAY command:**The client sends a command in the format PLAY name, where name is the name of the multimedia to be played. The server then plays the multimedia with the given name. For example, PLAY song1.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
13</h2>
<p>To change later</p>
<p>The best approach depends on your specific needs and the context of your application. Here are some considerations:</p>
<p>Using try-catch for each creation: This approach allows you to handle exceptions right where they occur. It provides a clear separation between normal code and error-handling code. However, it can make your code more verbose if you have many calls that can throw exceptions.</p>
<p>Returning a bool or a null pointer: This approach can make your code simpler and easier to read, especially if you have many calls that can fail. However, it can make it harder to provide detailed information about what went wrong, and it requires you to check the return value of each call.</p>
<p>In your case, if the creation of one item is independent of the creation of the others (i.e., if one creation fails, it doesn't affect the others), and if you want to attempt all creations even if some of them fail, it might be simpler and cleaner to use the second approach (returning a bool or a null pointer).</p>
<p>However, if the creations are dependent on each other (i.e., if one creation fails, the others shouldn't be attempted), or if you want to provide detailed error information when a creation fails, it might be better to use the first approach (using try-catch for each creation).</p>
<p>si le tableau de durées d'un <a class="el" href="classFilm.html" title="Classe représentant un film héritant de la classe Video.">Film</a> a une taille nulle ou inférieure à zéro si on crée plusieurs groupes ou objets ayant le même nom</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">BasePointer creerFilm(std::string nom, std::string nomDuFichier, int duree, int *chapitres, int taille)</div>
<div class="line">    {</div>
<div class="line">        // Check if a multimedia object with the same name already exists</div>
<div class="line">        if (Multimedia.find(nom) != Multimedia.end() || taille &lt;= 0)</div>
<div class="line">        {</div>
<div class="line">            // Return a null BasePointer</div>
<div class="line">            return BasePointer();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        // Create the new Film</div>
<div class="line">        BasePointer film(new Film(nom, nomDuFichier, duree, chapitres, taille));</div>
<div class="line">        Multimedia.insert(std::pair&lt;std::string, BasePointer&gt;(nom, film));</div>
<div class="line">        return film;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>si on supprime un groupe ou un objet qui n'existe pas</p>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">   void supprimer(const std::string &amp;nom)</div>
<div class="line">   {</div>
<div class="line">       auto multimedia_it = Multimedia.find(nom);</div>
<div class="line">       if (multimedia_it != Multimedia.end())</div>
<div class="line">       {</div>
<div class="line">           // Remove the multimedia object from all groups</div>
<div class="line">           for (auto &amp;pair : Groupes)</div>
<div class="line">           {</div>
<div class="line">               pair.second-&gt;enleverMultimedia(multimedia_it-&gt;second);</div>
<div class="line">           }</div>
<div class="line"> </div>
<div class="line">           // Delete the multimedia object</div>
<div class="line">           Multimedia.erase(multimedia_it);</div>
<div class="line">       }</div>
<div class="line">       else</div>
<div class="line">       {</div>
<div class="line">           auto group_it = Groupes.find(nom);</div>
<div class="line">           if (group_it != Groupes.end())</div>
<div class="line">           {</div>
<div class="line">               // Delete the group</div>
<div class="line">               Groupes.erase(group_it);</div>
<div class="line">           }</div>
<div class="line">           else</div>
<div class="line">           {</div>
<div class="line">               std::cout &lt;&lt; &quot;Object not found: &quot; &lt;&lt; nom &lt;&lt; &quot; &quot;;</div>
<div class="line">           }</div>
<div class="line">       }</div>
<div class="line">   }</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
